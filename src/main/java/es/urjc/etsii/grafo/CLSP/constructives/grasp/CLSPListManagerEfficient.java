package es.urjc.etsii.grafo.CLSP.constructives.grasp;

import es.urjc.etsii.grafo.CLSP.model.CLSPSolution;
import es.urjc.etsii.grafo.CLSP.model.WorkSlot;

import java.util.ArrayList;
import java.util.List;

public class CLSPListManagerEfficient extends CLSPListManager {



    /**
     * Update candidate list after each movement. The list will be sorted by the constructor.
     *
     * @param solution      Current solution, move has been already applied
     * @param move          Chosen move
     * @param index         index of the chosen move in the candidate list
     * @param candidateList original candidate list
     * @return an UNSORTED candidate list, where the best candidate is on the first position and the worst in the last
     */
    @Override
    public List<CLSPGRASPMove> updateCandidateList(CLSPSolution solution, CLSPGRASPMove move, List<CLSPGRASPMove> candidateList, int index) {

        List<CLSPGRASPMove> newCandidateList = new ArrayList<>(candidateList.size()-1);

        // List can be partially updated / modified
        for (int idx = 0; idx < candidateList.size(); idx++) {

            // Update the cost of the moves
            CLSPGRASPMove candidateMove = candidateList.get(idx);
            int machine = candidateMove.machine;

            // Skip of moves generated by the workslot affected for the already applied move
            if (candidateList.get(idx).workSlot == move.workSlot)
                continue;

            // CHANGEOVER TIME:
            double changeoverTime = solution.getChangeoverTime();
            // Add changeover time if the machine has workslots
            if (solution.getNumberOfMachineWorkSlots()[machine] > 0) {
                WorkSlot prev = solution.getSolutionData()[machine][solution.getNumberOfMachineWorkSlots()[machine] - 1];
                changeoverTime += solution.getInstance().changeoverTime[prev.getPartId()][candidateMove.workSlot.getPartId()];
            }
            // SHORTAGE:
            // Create new workslot sequence and calculate cost
            WorkSlot[] afterMoveEnd = new WorkSlot[solution.getNumberOfMachineWorkSlots()[machine] + 1];
            for (int i = 0; i < solution.getNumberOfMachineWorkSlots()[machine]; i++) {
                // Need to copy the workslot to not modify the solution (Mork requires this)
                afterMoveEnd[i] = new WorkSlot(solution.getSolutionData()[machine][i]);
            }
            // Add new workslot to the end of the machine
            afterMoveEnd[afterMoveEnd.length - 1] = candidateMove.workSlot;

            // Machine weekly produced parts for the move (different machines)
            int[][] machineIniWeeklyProducedParts = new int[solution.getInstance().getNumPeriods()][solution.getInstance().getNumParts()];
            int[][][] newWeeklyProducedParts = new int[solution.getInstance().getNumMachines()][solution.getInstance().getNumPeriods()][solution.getInstance().getNumParts()];

            // Calculate this machine's weekly production --> Use machineIniWeeklyProducedParts
            CLSPSolution.calculateMachineWeeklyProducedParts(solution.getInstance(), machineIniWeeklyProducedParts, afterMoveEnd, afterMoveEnd.length, machine);

            // Accumulate using the other machines' weekly production
            for (int machineId = 0; machineId < solution.getInstance().getNumMachines(); machineId++)
                if (machineId == machine) {
                    newWeeklyProducedParts[machineId] = machineIniWeeklyProducedParts;
                } else {
                    newWeeklyProducedParts[machineId] = solution.getMachineWeeklyProducedParts()[machineId];
                }

            // Calculate score
            var weeklyProductShortage = new int[solution.getInstance().getNumPeriods()][solution.getInstance().getNumParts()];
            var newWeeklyShortage = solution.fullCalculateWeeklyShortage(newWeeklyProducedParts, weeklyProductShortage);
            double shortage = solution.calculateShortageFunction(newWeeklyShortage);
            double newScore = solution.scoreCalculation(changeoverTime, shortage);

            // A new move has to be created to avoid modifying the original candidate list
            newCandidateList.add(new CLSPGRASPMove(solution, machine, candidateMove.workSlot, newScore - solution.getScore()));
        }

        return newCandidateList;

    }

}
